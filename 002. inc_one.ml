let rec inc_one lst = 
  match lst with
  | [] -> []
  | hd::tl -> (hd + 1)::(inc_one tl)

(*

1. hd는 head의 약자로 리스트의 첫 element를 말한다.
2. tl은 tail의 약자로 리스트의 첫 element를 제외한 나머지 리스트를 말한다.
3. ::는 리스트에 원소 1개를 넣는 연산자이다. 하지만, 리스트끼리는 ::를 쓸 수 없다.
  - a::b 라고 하면, a는 단일 element이고, b는 [] 형태의 리스트여야 한다.
  - [1]::[2;3;4];; 는 오류가 난다.
  - 1::[2;3;4];; 는 [1;2;3;4]가 된다.

예를 들어, 리스트 [1; 2; 3; 4]가 있을 때 hd는 1이고 tl은 2,3,4를 말한다.

  > match lst with
  1. 함수의 파라메터인 lst를 매치시킨다.

  > | [] -> []
  1. match에서 가장 먼저 나와야 한다. 이 부분은 입력과 출력의 형태를 지정해 준다.
  2. lst가 리스트의 형태이면, 리스트 형태로 리턴한다.

  > | hd::tl -> (hd + 1)::(inc_one tl)
  1. lst가 hd::tl 형태이면
    예를 들어, lst = [1;2;3;4;5]라면 hd는 1, tl은 1을 제외한 나머지인 2;3;4;5
    즉, [1]::[2;3;4;5] 의 형태이면 (hd + 1)::(inc_one tl)을 리턴하라는 뜻
    
    ::는 리스트를 두개 붙이라는 의미
    따라서 (hd + 1) = (1 + 1) = (2) 이고, (inc_one [2;3;4;5])를 해서 뒤에 붙여야 한다.
    즉, 2::(inc_one [2;3;4;5])를 리턴하게 된다.

  4. 여기서 inc_one [2;3;4;5] 는 recursive되어서 (2+1):: inc_one [3;4;5]가 된다.
    즉, 2::3::(inc_one [3;4;5]) 가 된다.

  5. 이것을 끝까지 반복하게 되면 2::3::4::5::6 이 되어서 [2;3;4;5;6]이 결과로 나오게 된다.

*)